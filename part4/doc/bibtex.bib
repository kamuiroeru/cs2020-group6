@article{do_developers,
    author = {Kula, Raula Gaikovina and German, Daniel M. and Ouni, Ali and Ishio, Takashi and Inoue, Katsuro},
    title = {Do Developers Update Their Library Dependencies?},
    year = {2018},
    journal = {Empirical Softw. Engg.}
}

@Article{Bavota2015,
author={Bavota, Gabriele
and Canfora, Gerardo
and Di Penta, Massimiliano
and Oliveto, Rocco
and Panichella, Sebastiano},
title={How the Apache community upgrades dependencies: an evolutionary study},
journal={Empirical Software Engineering},
year={2015},
month={Oct},
day={01},
volume={20},
number={5},
pages={1275-1317},
abstract={Software ecosystems consist of multiple software projects, often interrelated by means of dependency relations. When one project undergoes changes, other projects may decide to upgrade their dependency. For example, a project could use a new version of a component from another project because the latter has been enhanced or subject to some bug-fixing activities. In this paper we study the evolution of dependencies between projects in the Java subset of the Apache ecosystem, consisting of 147 projects, for a period of 14 years, resulting in 1,964 releases. Specifically, we investigate (i) how dependencies between projects evolve over time when the ecosystem grows, (ii) what are the product and process factors that can likely trigger dependency upgrades, (iii) how developers discuss the needs and risks of such upgrades, and (iv) what is the likely impact of upgrades on client projects. The study results---qualitatively confirmed by observations made by analyzing the developers' discussion---indicate that when a new release of a project is issued, it triggers an upgrade when the new release includes major changes (e.g., new features/services) as well as large amount of bug fixes. Instead, developers are reluctant to perform an upgrade when some APIs are removed. The impact of upgrades is generally low, unless it is related to frameworks/libraries used in crosscutting concerns. Results of this study can support the understanding of the of library/component upgrade phenomenon, and provide the basis for a new family of recommenders aimed at supporting developers in the complex (and risky) activity of managing library/component upgrade within their software projects.},
issn={1573-7616},
doi={10.1007/s10664-014-9325-9},
url={https://doi.org/10.1007/s10664-014-9325-9}
}

